{"version":3,"file":"static/js/7569.7974cd2a.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js","../node_modules/@babel/runtime/helpers/esm/checkPrivateRedeclaration.js","../node_modules/@babel/runtime/helpers/esm/assertClassBrand.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js","../node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot/src/slot.tsx","../node_modules/@radix-ui/react-collection/src/collection-legacy.tsx","../node_modules/@radix-ui/react-collection/src/ordered-dictionary.ts","../node_modules/@radix-ui/react-direction/src/direction.tsx"],"sourcesContent":["import checkPrivateRedeclaration from \"./checkPrivateRedeclaration.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nexport { _classPrivateFieldInitSpec as default };","function _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nexport { _checkPrivateRedeclaration as default };","function _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nexport { _assertClassBrand as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(assertClassBrand(s, a));\n}\nexport { _classPrivateFieldGet2 as default };","import assertClassBrand from \"./assertClassBrand.js\";\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(assertClassBrand(s, a), r), r;\n}\nexport { _classPrivateFieldSet2 as default };","import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n","import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n"],"names":["_classPrivateFieldInitSpec","e","t","a","has","TypeError","set","_assertClassBrand","n","arguments","length","_classPrivateFieldGet2","s","get","_classPrivateFieldSet2","r","createSlot","ownerName","SlotClone","createSlotClone","Slot2","React","props","forwardedRef","children","slotProps","_objectWithoutProperties","_excluded","childrenArray","toArray","slottable","find","isSlottable","newElement","newChildren","map","child","count","only","jsx","_objectSpread","ref","displayName","concat","_excluded2","childrenRef","element","_Object$getOwnPropert","_Object$getOwnPropert2","getter","Object","getOwnPropertyDescriptor","mayWarn","isReactWarning","getElementRef","props2","childProps","overrideProps","propName","slotPropValue","childPropValue","test","result","filter","Boolean","join","mergeProps","type","composeRefs","SLOTTABLE_IDENTIFIER","Symbol","__radixId","createCollection","name","PROVIDER_NAME","createCollectionContext","createCollectionScope","createContextScope","CollectionProviderImpl","useCollectionContext","collectionRef","current","itemMap","Map","CollectionProvider","scope","COLLECTION_SLOT_NAME","CollectionSlotImpl","CollectionSlot","context","composedRefs","useComposedRefs","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","delete","Provider","Slot","ItemSlot","collectionNode","orderedNodes","Array","from","querySelectorAll","values","sort","b","indexOf","__instanciated","WeakMap","_keys","at","array","index","prototype","call","actualIndex","relativeIndex","toSafeInteger","toSafeIndex","number","Math","trunc","DirectionContext","useDirection","localDir","globalDir"],"sourceRoot":""}